<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CarrotRush - Jogo Distribu칤do</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            border: 3px solid #8B4513;
            background: #90EE90;
            cursor: crosshair;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #8B4513;
            border-radius: 10px;
            padding: 15px;
            min-width: 200px;
            pointer-events: auto;
        }

        #leaderboard h3 {
            margin: 0 0 10px 0;
            color: #8B4513;
            text-align: center;
            font-size: 18px;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #ddd;
            font-size: 14px;
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .player-name {
            font-weight: bold;
            color: #2E8B57;
        }

        .player-score {
            color: #FF4500;
            font-weight: bold;
        }

        #playerInfo {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #8B4513;
            border-radius: 10px;
            padding: 15px;
            pointer-events: auto;
        }

        #playerInfo h3 {
            margin: 0 0 10px 0;
            color: #8B4513;
        }

        #connectionStatus {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #8B4513;
            border-radius: 10px;
            padding: 10px;
            pointer-events: auto;
        }

        .status-online {
            color: #008000;
            font-weight: bold;
        }

        .status-offline {
            color: #FF0000;
            font-weight: bold;
        }

        #joinForm {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 3px solid #8B4513;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            z-index: 100;
        }

        #joinForm h2 {
            color: #8B4513;
            margin-bottom: 20px;
        }

        #joinForm input {
            padding: 10px;
            border: 2px solid #8B4513;
            border-radius: 5px;
            margin: 10px;
            font-size: 16px;
        }

        #joinForm button {
            padding: 12px 25px;
            background: #FF4500;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }

        #joinForm button:hover {
            background: #FF6500;
        }

        .hidden {
            display: none;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #8B4513;
            border-radius: 10px;
            padding: 10px;
            font-size: 12px;
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Formul치rio de entrada -->
        <div id="joinForm">
            <h2>游냟 CarrotRush 游볫</h2>
            <p>Entre no jogo e colete cenouras!</p>
            <input type="text" id="playerName" placeholder="Seu nome" maxlength="15">
            <br>
            <button onclick="joinGame()">Entrar no Jogo</button>
        </div>

        <!-- Canvas do jogo -->
        <canvas id="gameCanvas" width="800" height="600" class="hidden"></canvas>

        <!-- Interface do usu치rio -->
        <div id="ui" class="hidden">
            <!-- Informa칞칫es do jogador -->
            <div id="playerInfo">
                <h3>Seu Coelho</h3>
                <div>Nome: <span id="playerNameDisplay"></span></div>
                <div>Pontos: <span id="playerScore">0</span></div>
            </div>

            <!-- Leaderboard -->
            <div id="leaderboard">
                <h3>游끥 Top 10</h3>
                <div id="leaderboardList">
                    <div class="leaderboard-item">
                        <span class="player-name">Aguardando...</span>
                        <span class="player-score">0</span>
                    </div>
                </div>
            </div>

            <!-- Status de conex칚o -->
            <div id="connectionStatus">
                Status: <span id="statusText" class="status-offline">Desconectado</span>
            </div>

            <!-- Controles -->
            <div id="controls">
                <strong>Controles:</strong><br>
                Clique: Mover coelho<br>
                Passar por cima: Coletar cenoura<br>
                游볫 Laranja: 1 ponto<br>
                游볫 Dourada: 5 pontos
            </div>
        </div>
    </div>

    <!-- Socket.io -->
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Configura칞칫es do jogo
        const GAME_CONFIG = {
            MAP_WIDTH: 2000,
            MAP_HEIGHT: 2000,
            CANVAS_WIDTH: 800,
            CANVAS_HEIGHT: 600,
            PLAYER_SIZE: 40,
            CARROT_SIZE: 30
        };

        // Vari치veis globais
        let socket;
        let gameState = {
            players: new Map(),
            carrots: new Map(),
            myPlayer: null,
            camera: { x: 0, y: 0 }
        };
        let canvas, ctx;
        let keys = {};
        let targetPosition = null;

        // Inicializa칞칚o
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Eventos do mouse
            canvas.addEventListener('click', handleClick);
            
            // Eventos do teclado
            document.addEventListener('keydown', (e) => keys[e.key] = true);
            document.addEventListener('keyup', (e) => keys[e.key] = false);
        }

        // Entrar no jogo
        function joinGame() {
            const playerName = document.getElementById('playerName').value.trim();
            if (!playerName) {
                alert('Por favor, digite seu nome!');
                return;
            }

            // Conectar ao servidor
            socket = io();
            setupSocketEvents();
            
            // Enviar dados do jogador
            socket.emit('player_join', { name: playerName });
            
            // Esconder formul치rio e mostrar jogo
            document.getElementById('joinForm').classList.add('hidden');
            document.getElementById('gameCanvas').classList.remove('hidden');
            document.getElementById('ui').classList.remove('hidden');
            
            document.getElementById('playerNameDisplay').textContent = playerName;
            
            // Iniciar loop do jogo
            gameLoop();
        }

        // Configurar eventos do socket
        function setupSocketEvents() {
            socket.on('connect', () => {
                updateConnectionStatus(true);
            });

            socket.on('disconnect', () => {
                updateConnectionStatus(false);
            });

            socket.on('game_state', (state) => {
                // Estado inicial do jogo
                gameState.players.clear();
                gameState.carrots.clear();
                
                state.players.forEach(player => {
                    gameState.players.set(player.id, player);
                    if (player.id === socket.id) {
                        gameState.myPlayer = player;
                    }
                });
                
                state.carrots.forEach(carrot => {
                    gameState.carrots.set(carrot.id, carrot);
                });
                
                updateLeaderboard(state.leaderboard);
                updatePlayerScore();
            });

            socket.on('player_joined', (player) => {
                gameState.players.set(player.id, player);
            });

            socket.on('player_left', (playerId) => {
                gameState.players.delete(playerId);
            });

            socket.on('player_moved', (data) => {
                const player = gameState.players.get(data.id);
                if (player) {
                    player.position = data.position;
                }
            });

            socket.on('carrot_spawned', (carrot) => {
                gameState.carrots.set(carrot.id, carrot);
            });

            socket.on('carrot_collected', (data) => {
                gameState.carrots.delete(data.carrotId);
                
                const player = gameState.players.get(data.playerId);
                if (player) {
                    player.score = data.playerScore;
                }
                
                if (data.playerId === socket.id) {
                    updatePlayerScore();
                }
            });

            socket.on('carrot_expired', (carrotId) => {
                gameState.carrots.delete(carrotId);
            });

            socket.on('leaderboard_update', (leaderboard) => {
                updateLeaderboard(leaderboard);
            });
        }

        // Atualizar status de conex칚o
        function updateConnectionStatus(connected) {
            const statusText = document.getElementById('statusText');
            if (connected) {
                statusText.textContent = 'Conectado';
                statusText.className = 'status-online';
            } else {
                statusText.textContent = 'Desconectado';
                statusText.className = 'status-offline';
            }
        }

        // Atualizar pontua칞칚o do jogador
        function updatePlayerScore() {
            if (gameState.myPlayer) {
                document.getElementById('playerScore').textContent = gameState.myPlayer.score;
            }
        }

        // Atualizar leaderboard
        function updateLeaderboard(leaderboard) {
            const list = document.getElementById('leaderboardList');
            list.innerHTML = '';
            
            if (leaderboard.length === 0) {
                list.innerHTML = '<div class="leaderboard-item"><span class="player-name">Aguardando...</span><span class="player-score">0</span></div>';
                return;
            }
            
            leaderboard.forEach((player, index) => {
                const item = document.createElement('div');
                item.className = 'leaderboard-item';
                item.innerHTML = `
                    <span class="player-name">${index + 1}. ${player.name}</span>
                    <span class="player-score">${player.score}</span>
                `;
                list.appendChild(item);
            });
        }

        // Manipular clique
        function handleClick(e) {
            if (!gameState.myPlayer) return;
            
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            // Definir posi칞칚o alvo no mundo
            targetPosition = {
                x: clickX + gameState.camera.x,
                y: clickY + gameState.camera.y
            };
        }

        // Verificar coleta de cenouras
        function checkCarrotCollection() {
            if (!gameState.myPlayer) return;
            
            for (let [carrotId, carrot] of gameState.carrots) {
                const distance = Math.sqrt(
                    Math.pow(gameState.myPlayer.position.x - carrot.position.x, 2) + 
                    Math.pow(gameState.myPlayer.position.y - carrot.position.y, 2)
                );
                
                if (distance <= GAME_CONFIG.CARROT_SIZE) {
                    socket.emit('collect_carrot', carrotId);
                    break;
                }
            }
        }

        // Atualizar posi칞칚o do jogador
        function updatePlayerPosition() {
            if (!gameState.myPlayer || !targetPosition) return;
            
            // Calcular dire칞칚o para o alvo
            const dx = targetPosition.x - gameState.myPlayer.position.x;
            const dy = targetPosition.y - gameState.myPlayer.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 5) { // Apenas mover se estiver longe o suficiente
                const speed = 2; // Velocidade de movimento
                const moveX = (dx / distance) * speed;
                const moveY = (dy / distance) * speed;
                
                // Atualizar posi칞칚o
                const newPos = {
                    x: Math.max(0, Math.min(GAME_CONFIG.MAP_WIDTH, gameState.myPlayer.position.x + moveX)),
                    y: Math.max(0, Math.min(GAME_CONFIG.MAP_HEIGHT, gameState.myPlayer.position.y + moveY))
                };
                
                gameState.myPlayer.position = newPos;
                
                // Enviar movimento para o servidor
                socket.emit('player_move', { position: newPos });
                
                // Atualizar c칙mera
                updateCamera();
                
                // Verificar coleta de cenouras
                checkCarrotCollection();
            } else {
                // Chegou ao destino
                targetPosition = null;
            }
        }

        // Atualizar c칙mera
        function updateCamera() {
            if (!gameState.myPlayer) return;
            
            // Centralizar c칙mera no jogador
            gameState.camera.x = gameState.myPlayer.position.x - GAME_CONFIG.CANVAS_WIDTH / 2;
            gameState.camera.y = gameState.myPlayer.position.y - GAME_CONFIG.CANVAS_HEIGHT / 2;
            
            // Limitar c칙mera aos limites do mapa
            gameState.camera.x = Math.max(0, Math.min(GAME_CONFIG.MAP_WIDTH - GAME_CONFIG.CANVAS_WIDTH, gameState.camera.x));
            gameState.camera.y = Math.max(0, Math.min(GAME_CONFIG.MAP_HEIGHT - GAME_CONFIG.CANVAS_HEIGHT, gameState.camera.y));
        }

        // Renderizar jogo
        function render() {
            // Limpar canvas
            ctx.fillStyle = '#90EE90';
            ctx.fillRect(0, 0, GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT);
            
            // Desenhar grid do mapa
            drawGrid();
            
            // Desenhar cenouras
            for (let [carrotId, carrot] of gameState.carrots) {
                drawCarrot(carrot);
            }
            
            // Desenhar jogadores
            for (let [playerId, player] of gameState.players) {
                drawPlayer(player, playerId === socket.id);
            }
            
            // Desenhar bordas do mapa
            drawMapBorders();
        }

        // Desenhar grid
        function drawGrid() {
            ctx.strokeStyle = 'rgba(139, 69, 19, 0.2)';
            ctx.lineWidth = 1;
            
            const gridSize = 100;
            const startX = Math.floor(gameState.camera.x / gridSize) * gridSize;
            const startY = Math.floor(gameState.camera.y / gridSize) * gridSize;
            
            // Linhas verticais
            for (let x = startX; x <= gameState.camera.x + GAME_CONFIG.CANVAS_WIDTH + gridSize; x += gridSize) {
                const screenX = x - gameState.camera.x;
                ctx.beginPath();
                ctx.moveTo(screenX, 0);
                ctx.lineTo(screenX, GAME_CONFIG.CANVAS_HEIGHT);
                ctx.stroke();
            }
            
            // Linhas horizontais
            for (let y = startY; y <= gameState.camera.y + GAME_CONFIG.CANVAS_HEIGHT + gridSize; y += gridSize) {
                const screenY = y - gameState.camera.y;
                ctx.beginPath();
                ctx.moveTo(0, screenY);
                ctx.lineTo(GAME_CONFIG.CANVAS_WIDTH, screenY);
                ctx.stroke();
            }
        }

        // Desenhar jogador
        function drawPlayer(player, isMe) {
            const screenX = player.position.x - gameState.camera.x;
            const screenY = player.position.y - gameState.camera.y;
            
            // Verificar se est치 vis칤vel
            if (screenX < -GAME_CONFIG.PLAYER_SIZE || screenX > GAME_CONFIG.CANVAS_WIDTH + GAME_CONFIG.PLAYER_SIZE ||
                screenY < -GAME_CONFIG.PLAYER_SIZE || screenY > GAME_CONFIG.CANVAS_HEIGHT + GAME_CONFIG.PLAYER_SIZE) {
                return;
            }
            
            // Corpo do coelho
            ctx.fillStyle = isMe ? '#FFB6C1' : '#F0E68C';
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2;
            
            // Corpo principal (oval)
            ctx.beginPath();
            ctx.ellipse(screenX, screenY + 5, GAME_CONFIG.PLAYER_SIZE / 3, GAME_CONFIG.PLAYER_SIZE / 2.5, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            // Cabe칞a
            ctx.beginPath();
            ctx.ellipse(screenX, screenY - 10, GAME_CONFIG.PLAYER_SIZE / 4, GAME_CONFIG.PLAYER_SIZE / 4, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            // Orelhas
            ctx.beginPath();
            ctx.ellipse(screenX - 8, screenY - 18, 4, 12, -0.3, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            ctx.beginPath();
            ctx.ellipse(screenX + 8, screenY - 18, 4, 12, 0.3, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            // Olhos
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(screenX - 5, screenY - 12, 2, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(screenX + 5, screenY - 12, 2, 0, 2 * Math.PI);
            ctx.fill();
            
            // Nariz
            ctx.fillStyle = '#FF69B4';
            ctx.beginPath();
            ctx.arc(screenX, screenY - 8, 1.5, 0, 2 * Math.PI);
            ctx.fill();
            
            // Nome do jogador
            if (isMe) {
                ctx.fillStyle = '#FF4500';
                ctx.font = 'bold 12px Arial';
            } else {
                ctx.fillStyle = '#2E8B57';
                ctx.font = '11px Arial';
            }
            ctx.textAlign = 'center';
            ctx.fillText(player.name, screenX, screenY + 30);
            
            // Pontua칞칚o
            ctx.fillStyle = '#8B4513';
            ctx.font = '10px Arial';
            ctx.fillText(`${player.score} pts`, screenX, screenY + 42);
        }

        // Desenhar cenoura
        function drawCarrot(carrot) {
            const screenX = carrot.position.x - gameState.camera.x;
            const screenY = carrot.position.y - gameState.camera.y;
            
            // Verificar se est치 vis칤vel
            if (screenX < -GAME_CONFIG.CARROT_SIZE || screenX > GAME_CONFIG.CANVAS_WIDTH + GAME_CONFIG.CARROT_SIZE ||
                screenY < -GAME_CONFIG.CARROT_SIZE || screenY > GAME_CONFIG.CANVAS_HEIGHT + GAME_CONFIG.CARROT_SIZE) {
                return;
            }
            
            // Cor da cenoura
            const color = carrot.type === 'golden' ? '#FFD700' : '#FF8C00';
            
            // Cenoura (tri칙ngulo)
            ctx.fillStyle = color;
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 1.5;
            
            ctx.beginPath();
            ctx.moveTo(screenX, screenY + 8);        // Ponta agora embaixo
            ctx.lineTo(screenX - 6, screenY - 8);    // Base agora em cima
            ctx.lineTo(screenX + 6, screenY - 8);    // Base agora em cima
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Folhas da cenoura
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.moveTo(screenX - 3, screenY - 8);
            ctx.lineTo(screenX - 6, screenY - 15);
            ctx.lineTo(screenX - 1, screenY - 12);
            ctx.lineTo(screenX + 1, screenY - 12);
            ctx.lineTo(screenX + 6, screenY - 15);
            ctx.lineTo(screenX + 3, screenY - 8);
            ctx.closePath();
            ctx.fill();
            
            // Efeito brilho para cenouras douradas
            if (carrot.type === 'golden') {
                const time = Date.now() / 300;
                const alpha = Math.sin(time) * 0.3 + 0.3;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.ellipse(screenX, screenY, 8, 8, 0, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        // Desenhar bordas do mapa
        function drawMapBorders() {
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 4;
            ctx.setLineDash([]);
            
            // Borda superior
            if (gameState.camera.y <= 2) {
                ctx.beginPath();
                ctx.moveTo(0, 2 - gameState.camera.y);
                ctx.lineTo(GAME_CONFIG.CANVAS_WIDTH, 2 - gameState.camera.y);
                ctx.stroke();
            }
            
            // Borda inferior
            if (gameState.camera.y + GAME_CONFIG.CANVAS_HEIGHT >= GAME_CONFIG.MAP_HEIGHT - 2) {
                const y = GAME_CONFIG.MAP_HEIGHT - gameState.camera.y - 2;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(GAME_CONFIG.CANVAS_WIDTH, y);
                ctx.stroke();
            }
            
            // Borda esquerda
            if (gameState.camera.x <= 2) {
                ctx.beginPath();
                ctx.moveTo(2 - gameState.camera.x, 0);
                ctx.lineTo(2 - gameState.camera.x, GAME_CONFIG.CANVAS_HEIGHT);
                ctx.stroke();
            }
            
            // Borda direita
            if (gameState.camera.x + GAME_CONFIG.CANVAS_WIDTH >= GAME_CONFIG.MAP_WIDTH - 2) {
                const x = GAME_CONFIG.MAP_WIDTH - gameState.camera.x - 2;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, GAME_CONFIG.CANVAS_HEIGHT);
                ctx.stroke();
            }
        }

        // Loop principal do jogo
        function gameLoop() {
            updatePlayerPosition();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Inicializar quando a p치gina carregar
        window.onload = init;
    </script>
</body>
</html>